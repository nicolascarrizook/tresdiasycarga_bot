"""
Database health checking utilities for Sistema Mayra.
"""
import asyncio
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass

from sqlalchemy import text, func
from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


@dataclass
class HealthCheckResult:
    """Health check result container."""
    component: str
    status: str  # healthy, unhealthy, warning
    timestamp: datetime
    response_time: float
    details: Dict[str, Any]
    error_message: Optional[str] = None


class DatabaseHealthChecker:
    """Database health checker with comprehensive monitoring."""
    
    def __init__(self, db_connection=None):
        self.db_connection = db_connection
        self.health_history: List[HealthCheckResult] = []
        self.max_history_size = 100
    
    async def check_connection(self) -> HealthCheckResult:
        """Check basic database connection."""
        start_time = datetime.utcnow()
        
        try:
            if not self.db_connection:
                from database.utils.connection import get_database_connection
                self.db_connection = get_database_connection()
            
            async with self.db_connection.get_async_session() as session:\n                result = await session.execute(text(\"SELECT 1\"))\n                result.scalar()\n            \n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"connection\",\n                status=\"healthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={\"query\": \"SELECT 1\", \"result\": \"success\"}\n            )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"connection\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={\"query\": \"SELECT 1\"},\n                error_message=str(e)\n            )\n    \n    async def check_database_size(self) -> HealthCheckResult:\n        \"\"\"Check database size and growth.\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            async with self.db_connection.get_async_session() as session:\n                # Get database size\n                size_result = await session.execute(text(\n                    \"SELECT pg_size_pretty(pg_database_size(current_database())) as pretty_size, \"\n                    \"pg_database_size(current_database()) as size_bytes\"\n                ))\n                size_data = size_result.fetchone()\n                \n                # Get tablespace usage\n                tablespace_result = await session.execute(text(\n                    \"SELECT spcname, pg_size_pretty(pg_tablespace_size(spcname)) as size \"\n                    \"FROM pg_tablespace\"\n                ))\n                tablespaces = [dict(row) for row in tablespace_result.fetchall()]\n                \n                response_time = (datetime.utcnow() - start_time).total_seconds()\n                \n                # Determine status based on size\n                size_bytes = size_data.size_bytes\n                status = \"healthy\"\n                if size_bytes > 10 * 1024 * 1024 * 1024:  # 10GB\n                    status = \"warning\"\n                elif size_bytes > 50 * 1024 * 1024 * 1024:  # 50GB\n                    status = \"unhealthy\"\n                \n                return HealthCheckResult(\n                    component=\"database_size\",\n                    status=status,\n                    timestamp=datetime.utcnow(),\n                    response_time=response_time,\n                    details={\n                        \"size_pretty\": size_data.pretty_size,\n                        \"size_bytes\": size_bytes,\n                        \"tablespaces\": tablespaces\n                    }\n                )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"database_size\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={},\n                error_message=str(e)\n            )\n    \n    async def check_table_health(self) -> HealthCheckResult:\n        \"\"\"Check table health and statistics.\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            async with self.db_connection.get_async_session() as session:\n                # Get table statistics\n                stats_result = await session.execute(text(\"\"\"\n                    SELECT \n                        schemaname,\n                        tablename,\n                        n_tup_ins as inserts,\n                        n_tup_upd as updates,\n                        n_tup_del as deletes,\n                        n_live_tup as live_rows,\n                        n_dead_tup as dead_rows,\n                        last_vacuum,\n                        last_analyze\n                    FROM pg_stat_user_tables\n                    ORDER BY n_live_tup DESC\n                    LIMIT 10\n                \"\"\"))\n                \n                table_stats = []\n                for row in stats_result.fetchall():\n                    table_stats.append({\n                        \"schema\": row.schemaname,\n                        \"table\": row.tablename,\n                        \"inserts\": row.inserts,\n                        \"updates\": row.updates,\n                        \"deletes\": row.deletes,\n                        \"live_rows\": row.live_rows,\n                        \"dead_rows\": row.dead_rows,\n                        \"last_vacuum\": row.last_vacuum,\n                        \"last_analyze\": row.last_analyze\n                    })\n                \n                # Check for tables needing maintenance\n                maintenance_needed = []\n                for table in table_stats:\n                    dead_ratio = table[\"dead_rows\"] / (table[\"live_rows\"] + 1)\n                    if dead_ratio > 0.1:  # More than 10% dead rows\n                        maintenance_needed.append(table[\"table\"])\n                \n                response_time = (datetime.utcnow() - start_time).total_seconds()\n                \n                status = \"healthy\"\n                if len(maintenance_needed) > 0:\n                    status = \"warning\"\n                if len(maintenance_needed) > 5:\n                    status = \"unhealthy\"\n                \n                return HealthCheckResult(\n                    component=\"table_health\",\n                    status=status,\n                    timestamp=datetime.utcnow(),\n                    response_time=response_time,\n                    details={\n                        \"table_stats\": table_stats,\n                        \"maintenance_needed\": maintenance_needed\n                    }\n                )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"table_health\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={},\n                error_message=str(e)\n            )\n    \n    async def check_connection_pool(self) -> HealthCheckResult:\n        \"\"\"Check connection pool health.\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            # Get connection pool info\n            pool_info = self.db_connection.get_engine_info()\n            \n            async with self.db_connection.get_async_session() as session:\n                # Get active connections\n                connections_result = await session.execute(text(\"\"\"\n                    SELECT \n                        count(*) as total_connections,\n                        count(*) FILTER (WHERE state = 'active') as active_connections,\n                        count(*) FILTER (WHERE state = 'idle') as idle_connections,\n                        count(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction\n                    FROM pg_stat_activity \n                    WHERE datname = current_database()\n                \"\"\"))\n                \n                conn_data = connections_result.fetchone()\n                \n                response_time = (datetime.utcnow() - start_time).total_seconds()\n                \n                # Determine status based on connection usage\n                total_connections = conn_data.total_connections\n                status = \"healthy\"\n                \n                if total_connections > 80:  # High connection count\n                    status = \"warning\"\n                elif total_connections > 150:  # Very high connection count\n                    status = \"unhealthy\"\n                \n                return HealthCheckResult(\n                    component=\"connection_pool\",\n                    status=status,\n                    timestamp=datetime.utcnow(),\n                    response_time=response_time,\n                    details={\n                        \"pool_info\": pool_info,\n                        \"total_connections\": total_connections,\n                        \"active_connections\": conn_data.active_connections,\n                        \"idle_connections\": conn_data.idle_connections,\n                        \"idle_in_transaction\": conn_data.idle_in_transaction\n                    }\n                )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"connection_pool\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={},\n                error_message=str(e)\n            )\n    \n    async def check_slow_queries(self) -> HealthCheckResult:\n        \"\"\"Check for slow queries.\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            async with self.db_connection.get_async_session() as session:\n                # Get slow queries (running for more than 30 seconds)\n                slow_queries_result = await session.execute(text(\"\"\"\n                    SELECT \n                        pid,\n                        now() - pg_stat_activity.query_start AS duration,\n                        query,\n                        state,\n                        usename\n                    FROM pg_stat_activity \n                    WHERE (now() - pg_stat_activity.query_start) > interval '30 seconds'\n                    AND state != 'idle'\n                    ORDER BY duration DESC\n                \"\"\"))\n                \n                slow_queries = []\n                for row in slow_queries_result.fetchall():\n                    slow_queries.append({\n                        \"pid\": row.pid,\n                        \"duration\": str(row.duration),\n                        \"query\": row.query[:200] + \"...\" if len(row.query) > 200 else row.query,\n                        \"state\": row.state,\n                        \"user\": row.usename\n                    })\n                \n                response_time = (datetime.utcnow() - start_time).total_seconds()\n                \n                status = \"healthy\"\n                if len(slow_queries) > 0:\n                    status = \"warning\"\n                if len(slow_queries) > 5:\n                    status = \"unhealthy\"\n                \n                return HealthCheckResult(\n                    component=\"slow_queries\",\n                    status=status,\n                    timestamp=datetime.utcnow(),\n                    response_time=response_time,\n                    details={\n                        \"slow_queries_count\": len(slow_queries),\n                        \"slow_queries\": slow_queries\n                    }\n                )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"slow_queries\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={},\n                error_message=str(e)\n            )\n    \n    async def check_replication(self) -> HealthCheckResult:\n        \"\"\"Check database replication status.\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            async with self.db_connection.get_async_session() as session:\n                # Check if this is a primary or replica\n                recovery_result = await session.execute(text(\n                    \"SELECT pg_is_in_recovery()\"\n                ))\n                is_replica = recovery_result.scalar()\n                \n                details = {\"is_replica\": is_replica}\n                \n                if not is_replica:\n                    # Primary server - check replication slots\n                    slots_result = await session.execute(text(\"\"\"\n                        SELECT \n                            slot_name,\n                            plugin,\n                            slot_type,\n                            database,\n                            active,\n                            restart_lsn,\n                            confirmed_flush_lsn\n                        FROM pg_replication_slots\n                    \"\"\"))\n                    \n                    replication_slots = [dict(row) for row in slots_result.fetchall()]\n                    details[\"replication_slots\"] = replication_slots\n                    \n                    # Check WAL files\n                    wal_result = await session.execute(text(\n                        \"SELECT count(*) FROM pg_ls_waldir()\"\n                    ))\n                    wal_count = wal_result.scalar()\n                    details[\"wal_files_count\"] = wal_count\n                else:\n                    # Replica server - check replication lag\n                    lag_result = await session.execute(text(\n                        \"SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())) as replication_lag\"\n                    ))\n                    lag = lag_result.scalar()\n                    details[\"replication_lag_seconds\"] = lag\n                \n                response_time = (datetime.utcnow() - start_time).total_seconds()\n                \n                # Determine status\n                status = \"healthy\"\n                if is_replica and details.get(\"replication_lag_seconds\", 0) > 60:\n                    status = \"warning\"\n                elif is_replica and details.get(\"replication_lag_seconds\", 0) > 300:\n                    status = \"unhealthy\"\n                \n                return HealthCheckResult(\n                    component=\"replication\",\n                    status=status,\n                    timestamp=datetime.utcnow(),\n                    response_time=response_time,\n                    details=details\n                )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"replication\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={},\n                error_message=str(e)\n            )\n    \n    async def check_locks(self) -> HealthCheckResult:\n        \"\"\"Check for database locks.\"\"\"\n        start_time = datetime.utcnow()\n        \n        try:\n            async with self.db_connection.get_async_session() as session:\n                # Get lock information\n                locks_result = await session.execute(text(\"\"\"\n                    SELECT \n                        pl.pid,\n                        pl.mode,\n                        pl.locktype,\n                        pl.granted,\n                        psa.query,\n                        psa.state,\n                        now() - psa.query_start AS duration\n                    FROM pg_locks pl\n                    JOIN pg_stat_activity psa ON pl.pid = psa.pid\n                    WHERE pl.granted = false\n                    OR (pl.granted = true AND pl.mode LIKE '%ExclusiveLock%')\n                    ORDER BY psa.query_start\n                \"\"\"))\n                \n                locks = []\n                for row in locks_result.fetchall():\n                    locks.append({\n                        \"pid\": row.pid,\n                        \"mode\": row.mode,\n                        \"locktype\": row.locktype,\n                        \"granted\": row.granted,\n                        \"query\": row.query[:200] + \"...\" if len(row.query) > 200 else row.query,\n                        \"state\": row.state,\n                        \"duration\": str(row.duration)\n                    })\n                \n                response_time = (datetime.utcnow() - start_time).total_seconds()\n                \n                # Count blocking locks\n                blocking_locks = [lock for lock in locks if not lock[\"granted\"]]\n                \n                status = \"healthy\"\n                if len(blocking_locks) > 0:\n                    status = \"warning\"\n                if len(blocking_locks) > 5:\n                    status = \"unhealthy\"\n                \n                return HealthCheckResult(\n                    component=\"locks\",\n                    status=status,\n                    timestamp=datetime.utcnow(),\n                    response_time=response_time,\n                    details={\n                        \"total_locks\": len(locks),\n                        \"blocking_locks\": len(blocking_locks),\n                        \"locks\": locks\n                    }\n                )\n        except Exception as e:\n            response_time = (datetime.utcnow() - start_time).total_seconds()\n            \n            return HealthCheckResult(\n                component=\"locks\",\n                status=\"unhealthy\",\n                timestamp=datetime.utcnow(),\n                response_time=response_time,\n                details={},\n                error_message=str(e)\n            )\n    \n    async def comprehensive_health_check(self) -> Dict[str, Any]:\n        \"\"\"Perform comprehensive health check.\"\"\"\n        checks = [\n            self.check_connection(),\n            self.check_database_size(),\n            self.check_table_health(),\n            self.check_connection_pool(),\n            self.check_slow_queries(),\n            self.check_replication(),\n            self.check_locks()\n        ]\n        \n        # Run all checks concurrently\n        results = await asyncio.gather(*checks, return_exceptions=True)\n        \n        # Process results\n        health_results = []\n        overall_status = \"healthy\"\n        \n        for i, result in enumerate(results):\n            if isinstance(result, Exception):\n                health_results.append(HealthCheckResult(\n                    component=f\"check_{i}\",\n                    status=\"unhealthy\",\n                    timestamp=datetime.utcnow(),\n                    response_time=0,\n                    details={},\n                    error_message=str(result)\n                ))\n                overall_status = \"unhealthy\"\n            else:\n                health_results.append(result)\n                \n                # Update overall status\n                if result.status == \"unhealthy\":\n                    overall_status = \"unhealthy\"\n                elif result.status == \"warning\" and overall_status == \"healthy\":\n                    overall_status = \"warning\"\n        \n        # Add to history\n        self.health_history.extend(health_results)\n        if len(self.health_history) > self.max_history_size:\n            self.health_history = self.health_history[-self.max_history_size:]\n        \n        return {\n            \"overall_status\": overall_status,\n            \"timestamp\": datetime.utcnow(),\n            \"checks\": [{\n                \"component\": result.component,\n                \"status\": result.status,\n                \"response_time\": result.response_time,\n                \"details\": result.details,\n                \"error_message\": result.error_message\n            } for result in health_results]\n        }\n    \n    def get_health_history(self, hours: int = 24) -> List[Dict[str, Any]]:\n        \"\"\"Get health check history.\"\"\"\n        cutoff_time = datetime.utcnow() - timedelta(hours=hours)\n        \n        return [{\n            \"component\": result.component,\n            \"status\": result.status,\n            \"timestamp\": result.timestamp,\n            \"response_time\": result.response_time,\n            \"details\": result.details,\n            \"error_message\": result.error_message\n        } for result in self.health_history if result.timestamp >= cutoff_time]\n    \n    def get_health_summary(self) -> Dict[str, Any]:\n        \"\"\"Get health summary statistics.\"\"\"\n        if not self.health_history:\n            return {\"status\": \"no_data\"}\n        \n        recent_checks = [r for r in self.health_history \n                        if r.timestamp >= datetime.utcnow() - timedelta(hours=1)]\n        \n        if not recent_checks:\n            return {\"status\": \"no_recent_data\"}\n        \n        # Calculate statistics\n        total_checks = len(recent_checks)\n        healthy_checks = len([r for r in recent_checks if r.status == \"healthy\"])\n        warning_checks = len([r for r in recent_checks if r.status == \"warning\"])\n        unhealthy_checks = len([r for r in recent_checks if r.status == \"unhealthy\"])\n        \n        avg_response_time = sum(r.response_time for r in recent_checks) / total_checks\n        \n        return {\n            \"status\": \"healthy\" if unhealthy_checks == 0 else \"unhealthy\",\n            \"total_checks\": total_checks,\n            \"healthy_percentage\": (healthy_checks / total_checks) * 100,\n            \"warning_percentage\": (warning_checks / total_checks) * 100,\n            \"unhealthy_percentage\": (unhealthy_checks / total_checks) * 100,\n            \"average_response_time\": avg_response_time,\n            \"last_check\": max(r.timestamp for r in recent_checks)\n        }"